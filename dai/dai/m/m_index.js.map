{"version":3,"sources":["webpack:///./src/common/assets/js/lazyload.js","webpack:///./src/module/m/assets/components/c-footer/index.js?9fca*","webpack:///./src/module/m/assets/components/c-footer/index.tpl.html?dd61*","webpack:///./src/module/m/assets/js/index.js","webpack:///./src/module/m/assets/js/swipe.js","webpack:///./src/module/m/assets/sass/index.scss"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD,sDAAqD;AACrD;AACA;AACA;AACA;AACA,QAAO,KAAK;AACZ;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA0D;AAC1D;AACA;AACA,oEAAmE;AACnE,UAAS;AACT;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,kBAAiB;AACjB;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mGAAkG;AAClG;AACA;AACA,sBAAqB;AACrB;AACA;AACA,kBAAiB,0BAA0B;AAC3C;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,qDAAoD;AACpD;AACA,sBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA,0BAAyB;AACzB,iEAAgE;AAChE;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA,kBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA,cAAa;;AAEb;AACA;AACA;AACA;AACA,kBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA,cAAa;;AAEb;AACA;AACA;AACA,cAAa;;AAEb;AACA;AACA;AACA,EAAC,C;;;;;;;;AC/TD;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACLA,ya;;;;;;;+CCAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,oBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA,kBAAiB;AACjB;AACA;AACA,gCAA+B,oBAAoB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA,kBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT,uBAAsB;AACtB;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,MAAK;AACL,EAAC;AACD;AACA;AACA;AACA,MAAK;AACL,EAAC,E;;;;;;;;AC5ED;;AAEA;;AAEA;AACA;AACA,OAAM;AACN;AACA;AACA,OAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,iEAAgE;;AAEhE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,2FAA0F;;AAE1F,UAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,UAAS;;AAET;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,UAAS;AACT;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,UAAS;AACT;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,0CAAyC;;AAEzC;AACA;AACA;;AAEA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAkC;;AAElC;AACA;AACA;AACA;AACA;;AAEA;;AAEA,UAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,kDAAiD;;AAEjD;AACA;AACA;AACA,8DAA6D;;AAE7D;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,kDAAiD;;AAEjD;AACA;;AAEA,0BAAyB;AACzB;AACA;;AAEA;AACA;AACA;;AAEA,sBAAqB;AACrB,kDAAiD;;AAEjD;AACA;;AAEA,0BAAyB;AACzB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,kBAAiB;;AAEjB;;AAEA;AACA;AACA;;AAEA,sBAAqB;;AAErB;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,UAAS;AACT;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA,WAAU;;AAEV;;AAEA;AACA;AACA;;AAEA;;AAEA,UAAS;AACT;;AAEA;AACA;;AAEA;;AAEA,UAAS;AACT;;AAEA;AACA;;AAEA;;AAEA,UAAS;AACT;;AAEA;AACA;;AAEA;;AAEA,UAAS;AACT;;AAEA;AACA;;AAEA,UAAS;AACT;;AAEA;AACA;;AAEA,UAAS;AACT;;AAEA;AACA;AACA,UAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,EAAC;AACD;AACA;AACA;AACA;AACA,MAAK;AACL,EAAC;AACD;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA,UAAS;AACT;AACA;;;;;;;;ACnlBA,0C","file":"m_index.js","sourcesContent":["/*!\r\n * An jQuery | zepto plugin for lazy loading images.\r\n * author -> jieyou\r\n * see https://github.com/jieyou/lazyload\r\n * use some tuupola's code https://github.com/tuupola/jquery_lazyload (BSD)\r\n * use component's throttle https://github.com/component/throttle (MIT)\r\n */\r\n;(function(factory){\r\n    //if(typeof define === 'function' && define.amd){ // AMD\r\n        // you may need to change `define([------>'jquery'<------], factory)` \r\n        // if you use zepto, change it rely name, such as `define(['zepto'], factory)`\r\n        //define(['jquery'], factory)\r\n         //define([Zepto], factory(Zepto))\r\n    //}else{ // Global\r\n        factory($);\r\n    //}\r\n})(function($,undefined){\r\n    var w = window,\r\n        $window = $(w),\r\n        defaultOptions = {\r\n            threshold                   : 0,\r\n            failure_limit               : 0,\r\n            event                       : 'scroll',\r\n            effect                      : 'show',\r\n            effect_params               : null,\r\n            container                   : w,\r\n            data_attribute              : 'original',\r\n            data_srcset_attribute       : 'original-srcset',\r\n            skip_invisible              : true,\r\n            appear                      : emptyFn,\r\n            load                        : emptyFn,\r\n            vertical_only               : false,\r\n            check_appear_throttle_time  : 300,\r\n            url_rewriter_fn             : emptyFn,\r\n            no_fake_img_loader          : false,\r\n            placeholder_data_img        : 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC',\r\n            // for IE6\\7 that does not support data image\r\n            placeholder_real_img        : 'http://ditu.baidu.cn/yyfm/lazyload/0.0.1/img/placeholder.png'\r\n            // todo : 将某些属性用global来配置，而不是每次在$(selector).lazyload({})内配置\r\n        },\r\n        type // function\r\n\r\n    function emptyFn(){}\r\n\r\n    type = (function(){\r\n        var object_prototype_toString = Object.prototype.toString\r\n        return function(obj){\r\n            // todo: compare the speeds of replace string twice or replace a regExp\r\n            return object_prototype_toString.call(obj).replace('[object ','').replace(']','')\r\n        }\r\n    })()\r\n\r\n    function belowthefold($element, options){\r\n        var fold\r\n        if(options._$container == $window){\r\n            fold = ('innerHeight' in w ? w.innerHeight : $window.height()) + $window.scrollTop()\r\n        }else{\r\n            fold = options._$container.offset().top + options._$container.height()\r\n        }\r\n        return fold <= $element.offset().top - options.threshold\r\n    }\r\n\r\n    function rightoffold($element, options){\r\n        var fold\r\n        if(options._$container == $window){\r\n            // Zepto do not support `$window.scrollLeft()` yet.\r\n            fold = $window.width() + ($.fn.scrollLeft?$window.scrollLeft():w.pageXOffset)\r\n        }else{\r\n            fold = options._$container.offset().left + options._$container.width()\r\n        }\r\n        return fold <= $element.offset().left - options.threshold\r\n    }\r\n\r\n    function abovethetop($element, options){\r\n        var fold\r\n        if(options._$container == $window){\r\n            fold = $window.scrollTop()\r\n        }else{\r\n            fold = options._$container.offset().top\r\n        }\r\n        // console.log('abovethetop fold '+ fold)\r\n        // console.log('abovethetop $element.height() '+ $element.height())\r\n        return fold >= $element.offset().top + options.threshold  + $element.height()\r\n    }\r\n\r\n    function leftofbegin($element, options){\r\n        var fold\r\n        if(options._$container == $window){\r\n            // Zepto do not support `$window.scrollLeft()` yet.\r\n            fold = $.fn.scrollLeft?$window.scrollLeft():w.pageXOffset\r\n        }else{\r\n            fold = options._$container.offset().left\r\n        }\r\n        return fold >= $element.offset().left + options.threshold + $element.width()\r\n    }\r\n\r\n    function checkAppear($elements, options){\r\n        var counter = 0\r\n        $elements.each(function(i,e){\r\n            var $element = $elements.eq(i)\r\n            if(($element.width() <= 0 && $element.height() <= 0) || $element.css('display') === 'none'){\r\n                return\r\n            }\r\n            function appear(){\r\n                $element.trigger('_lazyload_appear')\r\n                // if we found an image we'll load, reset the counter \r\n                counter = 0\r\n            }\r\n            // If vertical_only is set to true, only check the vertical to decide appear or not\r\n            // In most situations, page can only scroll vertically, set vertical_only to true will improve performance\r\n            if(options.vertical_only){\r\n                if(abovethetop($element, options)){\r\n                    // Nothing. \r\n                }else if(!belowthefold($element, options)){\r\n                    appear()\r\n                }else{\r\n                    if(++counter > options.failure_limit){\r\n                        return false\r\n                    }\r\n                }\r\n            }else{\r\n                if(abovethetop($element, options) || leftofbegin($element, options)){\r\n                    // Nothing. \r\n                }else if(!belowthefold($element, options) && !rightoffold($element, options)){\r\n                    appear()\r\n                }else{\r\n                    if(++counter > options.failure_limit){\r\n                        return false\r\n                    }\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    // Remove image from array so it is not looped next time. \r\n    function getUnloadElements($elements){\r\n        return $elements.filter(function(i,e){\r\n            return !$elements.eq(i)._lazyload_loadStarted\r\n        })\r\n    }\r\n\r\n    // throttle : https://github.com/component/throttle , MIT License\r\n    function throttle (func, wait) {\r\n        var ctx, args, rtn, timeoutID // caching\r\n        var last = 0\r\n\r\n        return function throttled () {\r\n            ctx = this\r\n            args = arguments\r\n            var delta = new Date() - last\r\n            if (!timeoutID)\r\n                if (delta >= wait) call()\r\n                else timeoutID = setTimeout(call, wait - delta)\r\n            return rtn\r\n        }\r\n\r\n        function call () {\r\n            timeoutID = 0\r\n            last = +new Date()\r\n            rtn = func.apply(ctx, args)\r\n            ctx = null\r\n            args = null\r\n        }\r\n    }\r\n\r\n    if(!$.fn.hasOwnProperty('lazyload')){\r\n\r\n        $.fn.lazyload = function(options){\r\n            var $elements = this,\r\n                isScrollEvent,\r\n                isScrollTypeEvent,\r\n                throttleCheckAppear\r\n\r\n            if(!$.isPlainObject(options)){\r\n                options = {}\r\n            }\r\n\r\n            $.each(defaultOptions,function(k,v){\r\n                if($.inArray(k,['threshold','failure_limit','check_appear_throttle_time']) != -1){ // these params can be a string\r\n                    if(type(options[k]) == 'String'){\r\n                        options[k] = parseInt(options[k],10)\r\n                    }else{\r\n                        options[k] = v\r\n                    }\r\n                }else if(k == 'container'){ // options.container can be a seletor string \\ dom \\ jQuery object\r\n                    if(options.hasOwnProperty(k)){\r\n                        if(options[k] == w || options[k] == document){\r\n                            options._$container = $window\r\n                        }else{\r\n                            options._$container = $(options[k])\r\n                        }\r\n                    }else{\r\n                        options._$container = $window\r\n                    }\r\n                    delete options.container\r\n                }else if(defaultOptions.hasOwnProperty(k) && (!options.hasOwnProperty(k) || (type(options[k]) != type(defaultOptions[k])))){\r\n                    options[k] = v\r\n                }\r\n            })\r\n\r\n            isScrollEvent = options.event == 'scroll'\r\n            throttleCheckAppear = options.check_appear_throttle_time == 0?\r\n                checkAppear\r\n                :throttle(checkAppear,options.check_appear_throttle_time)\r\n\r\n            // isScrollTypeEvent cantains custom scrollEvent . Such as 'scrollstart' & 'scrollstop'\r\n            // https://github.com/search?utf8=%E2%9C%93&q=scrollstart\r\n            isScrollTypeEvent = isScrollEvent || options.event == 'scrollstart' || options.event == 'scrollstop'\r\n\r\n            $elements.each(function(i,e){\r\n                var element = this,\r\n                    $element = $elements.eq(i),\r\n                    placeholderSrc = $element.attr('src'),\r\n                    originalSrcInAttr = $element.attr('data-'+options.data_attribute), // `data-original` attribute value\r\n                    originalSrc = options.url_rewriter_fn == emptyFn?\r\n                        originalSrcInAttr:\r\n                        options.url_rewriter_fn.call(element,$element,originalSrcInAttr),\r\n                    originalSrcset = $element.attr('data-'+options.data_srcset_attribute),\r\n                    isImg = $element.is('img')\r\n\r\n                if($element._lazyload_loadStarted == true || placeholderSrc == originalSrc){\r\n                    $element._lazyload_loadStarted = true\r\n                    $elements = getUnloadElements($elements)\r\n                    return\r\n                }\r\n\r\n                $element._lazyload_loadStarted = false\r\n\r\n                // If element is an img and no src attribute given, use placeholder. \r\n                if(isImg && !placeholderSrc){\r\n                    // For browsers that do not support data image.\r\n                    $element.one('error',function(){ // `on` -> `one` : IE6 triggered twice error event sometimes\r\n                        $element.attr('src',options.placeholder_real_img)\r\n                    }).attr('src',options.placeholder_data_img)\r\n                }\r\n\r\n                // When appear is triggered load original image. \r\n                $element.one('_lazyload_appear',function(){\r\n                    var effectParamsIsArray = $.isArray(options.effect_params),\r\n                        effectIsNotImmediacyShow\r\n                    function loadFunc(){\r\n                        // In most situations, the effect is immediacy show, at this time there is no need to hide element first\r\n                        // Hide this element may cause css reflow, call it as less as possible\r\n                        if(effectIsNotImmediacyShow){\r\n                            // todo: opacity:0 for fadeIn effect\r\n                            $element.hide()\r\n                        }\r\n                        if(isImg){\r\n                            // attr srcset first\r\n                            if(originalSrcset){\r\n                                $element.attr('srcset', originalSrcset)\r\n                            }\r\n                            if(originalSrc){\r\n                                $element.attr('src', originalSrc)\r\n                            }\r\n                        }else{\r\n                            $element.css('background-image','url(\"' + originalSrc + '\")')\r\n                        }\r\n                        if(effectIsNotImmediacyShow){\r\n                            $element[options.effect].apply($element,effectParamsIsArray?options.effect_params:[])\r\n                        }\r\n                        $elements = getUnloadElements($elements)\r\n                    }\r\n                    if(!$element._lazyload_loadStarted){\r\n                        effectIsNotImmediacyShow = (options.effect != 'show' && $.fn[options.effect] && (!options.effect_params || (effectParamsIsArray && options.effect_params.length == 0)))\r\n                        if(options.appear != emptyFn){\r\n                            options.appear.call(element, $element, $elements.length, options)\r\n                        }\r\n                        $element._lazyload_loadStarted = true\r\n                        if(options.no_fake_img_loader || originalSrcset){\r\n                            if(options.load != emptyFn){\r\n                                $element.one('load',function(){\r\n                                    options.load.call(element, $element, $elements.length, options)\r\n                                })\r\n                            }\r\n                            loadFunc()\r\n                        }else{\r\n                            $('<img />').one('load', function(){ // `on` -> `one` : IE6 triggered twice load event sometimes\r\n                                loadFunc()\r\n                                if(options.load != emptyFn){\r\n                                    options.load.call(element, $element, $elements.length, options)\r\n                                }\r\n                            }).attr('src',originalSrc)\r\n                        }\r\n                    }\r\n                })\r\n\r\n                // When wanted event is triggered load original image \r\n                // by triggering appear.                              \r\n                if (!isScrollTypeEvent){\r\n                    $element.on(options.event, function(){\r\n                        if (!$element._lazyload_loadStarted){\r\n                            $element.trigger('_lazyload_appear')\r\n                        }\r\n                    })\r\n                }\r\n            })\r\n\r\n            // Fire one scroll event per scroll. Not one scroll event per image. \r\n            if(isScrollTypeEvent){\r\n                options._$container.on(options.event, function(){\r\n                    throttleCheckAppear($elements, options)\r\n                })\r\n            }\r\n\r\n            // Check if something appears when window is resized. \r\n            // Force initial check if images should appear when window is onload. \r\n            $window.on('resize load', function(){\r\n                throttleCheckAppear($elements, options)\r\n            })\r\n\r\n            // Force initial check if images should appear. \r\n            $(function(){\r\n                throttleCheckAppear($elements, options)\r\n            })\r\n\r\n            return this\r\n        }\r\n    }\r\n})\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/common/assets/js/lazyload.js\n// module id = 28\n// module chunks = 3","module.exports = {\r\n    replace: true,\r\n    template: require('./index.tpl.html'),\r\n    methods: {\r\n    }\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/module/m/assets/components/c-footer/index.js\n// module id = 13\n// module chunks = 0 2 3 4","module.exports = \"<div class=\\\"footer-wrap clear\\\">\\r\\n    <div class=\\\"footer-fl\\\">\\r\\n        <ul class=\\\"clear\\\">\\r\\n            <li><a href=\\\"index.html\\\">首页</a></li>\\r\\n            <li><a href=\\\"cn.html\\\">超能模式</a></li>\\r\\n            <li><a href=\\\"contact.html\\\">联系我们</a></li>\\r\\n        </ul>\\r\\n    </div>\\r\\n    <div class=\\\"footer-fr\\\">\\r\\n        <div class=\\\"phone-wrap center_y\\\"></div>\\r\\n    </div>\\r\\n</div>\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/module/m/assets/components/c-footer/index.tpl.html\n// module id = 14\n// module chunks = 0 2 3 4","require('../sass/index.scss');\r\nconst Swipe = require('../js/swipe.js');\r\nrequire('../../../../common/assets/js/lazyload.js');\r\n(function () {\r\n    var vm = new Vue({\r\n        el: '#main',\r\n        data: {\r\n            loadFlag: true\r\n        },\r\n        methods: {},\r\n        events: {\r\n            swipeImg: function () {\r\n                var $screenshots = $('#shots');\r\n                var mySwipe = Swipe($screenshots[0], {\r\n                    speed: 400,\r\n                    auto: 3000,\r\n                    continuous: true,\r\n                    stopPropagation: true,\r\n                    callback: function (index, elem) {\r\n                        slideTab(index);\r\n                        changeDecs(index);\r\n                    },\r\n                    transitionEnd: function (index, elem) {\r\n                    }\r\n                });\r\n                //点击数字跳转到相应的面板\r\n                var bullets = $('.shots-tool .btn').find('li');\r\n                for (var i = 0; i < bullets.length; i++) {\r\n                    var elem = bullets[i];\r\n                    elem.setAttribute('data-tab', i);\r\n                    elem.onclick = function () {\r\n                        mySwipe.slide(parseInt(this.getAttribute('data-tab'), 10), 500);\r\n                    }\r\n                }\r\n                //数字导航on\r\n                function slideTab(index) {\r\n                    var i = bullets.length, len = i;\r\n                    while (i--) {\r\n                        bullets[i].className = bullets[i].className.replace('on', ' ');\r\n                    }\r\n                    try {\r\n                        bullets[index].className = 'on';\r\n                    } catch (ex) {\r\n                        bullets[index - len].className = 'on';\r\n                    }\r\n                }\r\n\r\n                setTimeout(function () {\r\n                    $screenshots.find('li').removeClass('hidden');\r\n                }, 1000);\r\n                var $decs = $('.shots-desc ul').find('li');\r\n\r\n                function changeDecs(index) {\r\n                    $decs.eq(index).addClass('on').siblings().removeClass('on');\r\n                }\r\n            }\r\n        },\r\n        components: {\r\n            'c-footer': require('../components/c-footer'),\r\n            'c-header': require('../components/c-header')\r\n        },\r\n        directives: {},\r\n        ready: function () {\r\n        }\r\n    });\r\n    vm.$emit('swipeImg');\r\n\r\n    $('.lazy').lazyload({\r\n        event: \"loadImg\",\r\n        skip_invisible: false\r\n    });\r\n})();\r\n$(window).bind(\"load\", function () {\r\n    var timeout = setTimeout(function () {\r\n        $('.lazy').trigger(\"loadImg\");\r\n    }, 10);\r\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/module/m/assets/js/index.js\n// module id = 0\n// module chunks = 3","function Swipe(container, options) {\r\n\r\n    \"use strict\";\r\n\r\n    // utilities\r\n    var noop = function () {\r\n    }; // simple no operation function\r\n    var offloadFn = function (fn) {\r\n        setTimeout(fn || noop, 0)\r\n    }; // offload a functions execution\r\n\r\n    // check browser capabilities\r\n    var browser = {\r\n        addEventListener: !!window.addEventListener,\r\n        touch: ('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch,\r\n        transitions: (function (temp) {\r\n            var props = ['transitionProperty', 'WebkitTransition', 'MozTransition', 'OTransition', 'msTransition'];\r\n            for (var i in props) if (temp.style[props[i]] !== undefined) return true;\r\n            return false;\r\n        })(document.createElement('swipe'))\r\n    };\r\n\r\n    // quit if no root element\r\n    if (!container) return;\r\n    var element = container.children[0];\r\n    var slides, slidePos, width, length;\r\n    options = options || {};\r\n    var index = parseInt(options.startSlide, 10) || 0;\r\n    var speed = options.speed || 300;\r\n    options.continuous = options.continuous !== undefined ? options.continuous : true;\r\n\r\n    function setup() {\r\n\r\n        // cache slides\r\n        slides = element.children;\r\n        length = slides.length;\r\n\r\n        // set continuous to false if only one slide\r\n        if (slides.length < 2) options.continuous = false;\r\n\r\n        //special case if two slides\r\n        if (browser.transitions && options.continuous && slides.length < 3) {\r\n            element.appendChild(slides[0].cloneNode(true));\r\n            element.appendChild(element.children[1].cloneNode(true));\r\n            slides = element.children;\r\n        }\r\n\r\n        // create an array to store current positions of each slide\r\n        slidePos = new Array(slides.length);\r\n\r\n        // determine width of each slide\r\n        width = container.getBoundingClientRect().width || container.offsetWidth;\r\n\r\n        element.style.width = (slides.length * width) + 'px';\r\n\r\n        // stack elements\r\n        var pos = slides.length;\r\n        while (pos--) {\r\n\r\n            var slide = slides[pos];\r\n\r\n            slide.style.width = width + 'px';\r\n            slide.setAttribute('data-index', pos);\r\n\r\n            if (browser.transitions) {\r\n                slide.style.left = (pos * -width) + 'px';\r\n                move(pos, index > pos ? -width : (index < pos ? width : 0), 0);\r\n            }\r\n\r\n        }\r\n\r\n        // reposition elements before and after index\r\n        if (options.continuous && browser.transitions) {\r\n            move(circle(index - 1), -width, 0);\r\n            move(circle(index + 1), width, 0);\r\n        }\r\n\r\n        if (!browser.transitions) element.style.left = (index * -width) + 'px';\r\n\r\n        container.style.visibility = 'visible';\r\n\r\n    }\r\n\r\n    function prev() {\r\n\r\n        if (options.continuous) slide(index - 1);\r\n        else if (index) slide(index - 1);\r\n\r\n    }\r\n\r\n    function next() {\r\n\r\n        if (options.continuous) slide(index + 1);\r\n        else if (index < slides.length - 1) slide(index + 1);\r\n\r\n    }\r\n\r\n    function circle(index) {\r\n\r\n        // a simple positive modulo using slides.length\r\n        return (slides.length + (index % slides.length)) % slides.length;\r\n\r\n    }\r\n\r\n    function slide(to, slideSpeed) {\r\n\r\n        // do nothing if already on requested slide\r\n        if (index == to) return;\r\n\r\n        if (browser.transitions) {\r\n\r\n            var direction = Math.abs(index - to) / (index - to); // 1: backward, -1: forward\r\n\r\n            // get the actual position of the slide\r\n            if (options.continuous) {\r\n                var natural_direction = direction;\r\n                direction = -slidePos[circle(to)] / width;\r\n\r\n                // if going forward but to < index, use to = slides.length + to\r\n                // if going backward but to > index, use to = -slides.length + to\r\n                if (direction !== natural_direction) to = -direction * slides.length + to;\r\n\r\n            }\r\n\r\n            var diff = Math.abs(index - to) - 1;\r\n\r\n            // move all the slides between index and to in the right direction\r\n            while (diff--) move(circle((to > index ? to : index) - diff - 1), width * direction, 0);\r\n\r\n            to = circle(to);\r\n\r\n            move(index, width * direction, slideSpeed || speed);\r\n            move(to, 0, slideSpeed || speed);\r\n\r\n            if (options.continuous) move(circle(to - direction), -(width * direction), 0); // we need to get the next in place\r\n\r\n        } else {\r\n\r\n            to = circle(to);\r\n            animate(index * -width, to * -width, slideSpeed || speed);\r\n            //no fallback for a circular continuous if the browser does not accept transitions\r\n        }\r\n\r\n        index = to;\r\n        offloadFn(options.callback && options.callback(index, slides[index]));\r\n    }\r\n\r\n    function move(index, dist, speed) {\r\n\r\n        translate(index, dist, speed);\r\n        slidePos[index] = dist;\r\n\r\n    }\r\n\r\n    function translate(index, dist, speed) {\r\n\r\n        var slide = slides[index];\r\n        var style = slide && slide.style;\r\n\r\n        if (!style) return;\r\n\r\n        style.webkitTransitionDuration =\r\n            style.MozTransitionDuration =\r\n                style.msTransitionDuration =\r\n                    style.OTransitionDuration =\r\n                        style.transitionDuration = speed + 'ms';\r\n\r\n        style.webkitTransform = 'translate(' + dist + 'px,0)' + 'translateZ(0)';\r\n        style.msTransform =\r\n            style.MozTransform =\r\n                style.OTransform = 'translateX(' + dist + 'px)';\r\n\r\n    }\r\n\r\n    function animate(from, to, speed) {\r\n\r\n        // if not an animation, just reposition\r\n        if (!speed) {\r\n\r\n            element.style.left = to + 'px';\r\n            return;\r\n\r\n        }\r\n\r\n        var start = +new Date;\r\n\r\n        var timer = setInterval(function () {\r\n\r\n            var timeElap = +new Date - start;\r\n\r\n            if (timeElap > speed) {\r\n\r\n                element.style.left = to + 'px';\r\n\r\n                if (delay) begin();\r\n\r\n                options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);\r\n\r\n                clearInterval(timer);\r\n                return;\r\n\r\n            }\r\n\r\n            element.style.left = (( (to - from) * (Math.floor((timeElap / speed) * 100) / 100) ) + from) + 'px';\r\n\r\n        }, 4);\r\n\r\n    }\r\n\r\n    // setup auto slideshow\r\n    var delay = options.auto || 0;\r\n    var interval;\r\n\r\n    function begin() {\r\n\r\n        interval = setTimeout(next, delay);\r\n\r\n    }\r\n\r\n    function stop() {\r\n\r\n        //delay = 0;\r\n        delay = options.auto > 0 ? options.auto : 0;\r\n        clearTimeout(interval);\r\n\r\n    }\r\n\r\n\r\n    // setup initial vars\r\n    var start = {};\r\n    var delta = {};\r\n    var isScrolling;\r\n\r\n    // setup event capturing\r\n    var events = {\r\n\r\n        handleEvent: function (event) {\r\n\r\n            switch (event.type) {\r\n                case 'touchstart':\r\n                    this.start(event);\r\n                    break;\r\n                case 'touchmove':\r\n                    this.move(event);\r\n                    break;\r\n                case 'touchend':\r\n                    offloadFn(this.end(event));\r\n                    break;\r\n                case 'webkitTransitionEnd':\r\n                case 'msTransitionEnd':\r\n                case 'oTransitionEnd':\r\n                case 'otransitionend':\r\n                case 'transitionend':\r\n                    offloadFn(this.transitionEnd(event));\r\n                    break;\r\n                case 'resize':\r\n                    offloadFn(setup);\r\n                    break;\r\n            }\r\n\r\n            if (options.stopPropagation) event.stopPropagation();\r\n\r\n        },\r\n        start: function (event) {\r\n\r\n            var touches = event.touches[0];\r\n\r\n            // measure start values\r\n            start = {\r\n\r\n                // get initial touch coords\r\n                x: touches.pageX,\r\n                y: touches.pageY,\r\n\r\n                // store time to determine touch duration\r\n                time: +new Date\r\n\r\n            };\r\n\r\n            // used for testing first move event\r\n            isScrolling = undefined;\r\n\r\n            // reset delta and end measurements\r\n            delta = {};\r\n\r\n            // attach touchmove and touchend listeners\r\n            element.addEventListener('touchmove', this, false);\r\n            element.addEventListener('touchend', this, false);\r\n\r\n        },\r\n        move: function (event) {\r\n\r\n            // ensure swiping with one touch and not pinching\r\n            if (event.touches.length > 1 || event.scale && event.scale !== 1) return\r\n\r\n            if (options.disableScroll) event.preventDefault();\r\n\r\n            var touches = event.touches[0];\r\n\r\n            // measure change in x and y\r\n            delta = {\r\n                x: touches.pageX - start.x,\r\n                y: touches.pageY - start.y\r\n            }\r\n\r\n            // determine if scrolling test has run - one time test\r\n            if (typeof isScrolling == 'undefined') {\r\n                isScrolling = !!( isScrolling || Math.abs(delta.x) < Math.abs(delta.y) );\r\n            }\r\n\r\n            // if user is not trying to scroll vertically\r\n            if (!isScrolling) {\r\n\r\n                // prevent native scrolling\r\n                event.preventDefault();\r\n\r\n                // stop slideshow\r\n                stop();\r\n\r\n                // increase resistance if first or last slide\r\n                if (options.continuous) { // we don't add resistance at the end\r\n\r\n                    translate(circle(index - 1), delta.x + slidePos[circle(index - 1)], 0);\r\n                    translate(index, delta.x + slidePos[index], 0);\r\n                    translate(circle(index + 1), delta.x + slidePos[circle(index + 1)], 0);\r\n\r\n                } else {\r\n                    //去除首页向右或者末页向左滑动的回弹效果\r\n                    if (!index && delta.x > 0 || index == slides.length - 1 && delta.x < 0) {\r\n                        return;\r\n                    }\r\n\r\n                    delta.x =\r\n                        delta.x /\r\n                        ( (!index && delta.x > 0               // if first slide and sliding left\r\n                            || index == slides.length - 1        // or if last slide and sliding right\r\n                            && delta.x < 0                       // and if sliding at all\r\n                        ) ?\r\n                            ( Math.abs(delta.x) / width + 1 )      // determine resistance level\r\n                            : 1 );                                 // no resistance if false\r\n\r\n                    // translate 1:1\r\n                    translate(index - 1, delta.x + slidePos[index - 1], 0);\r\n                    translate(index, delta.x + slidePos[index], 0);\r\n                    translate(index + 1, delta.x + slidePos[index + 1], 0);\r\n                }\r\n\r\n            }\r\n\r\n        },\r\n        end: function (event) {\r\n\r\n            // measure duration\r\n            var duration = +new Date - start.time;\r\n\r\n            // determine if slide attempt triggers next/prev slide\r\n            var isValidSlide =\r\n                Number(duration) < 250               // if slide duration is less than 250ms\r\n                && Math.abs(delta.x) > 20            // and if slide amt is greater than 20px\r\n                || Math.abs(delta.x) > width / 2;      // or if slide amt is greater than half the width\r\n\r\n            // determine if slide attempt is past start and end\r\n            var isPastBounds =\r\n                !index && delta.x > 0                            // if first slide and slide amt is greater than 0\r\n                || index == slides.length - 1 && delta.x < 0;    // or if last slide and slide amt is less than 0\r\n\r\n            if (options.continuous) isPastBounds = false;\r\n\r\n            // determine direction of swipe (true:right, false:left)\r\n            var direction = delta.x < 0;\r\n\r\n            // if not scrolling vertically\r\n            if (!isScrolling) {\r\n\r\n                if (isValidSlide && !isPastBounds) {\r\n\r\n                    if (direction) {\r\n\r\n                        if (options.continuous) { // we need to get the next in this direction in place\r\n\r\n                            move(circle(index - 1), -width, 0);\r\n                            move(circle(index + 2), width, 0);\r\n\r\n                        } else {\r\n                            move(index - 1, -width, 0);\r\n                        }\r\n\r\n                        move(index, slidePos[index] - width, speed);\r\n                        move(circle(index + 1), slidePos[circle(index + 1)] - width, speed);\r\n                        index = circle(index + 1);\r\n\r\n                    } else {\r\n                        if (options.continuous) { // we need to get the next in this direction in place\r\n\r\n                            move(circle(index + 1), width, 0);\r\n                            move(circle(index - 2), -width, 0);\r\n\r\n                        } else {\r\n                            move(index + 1, width, 0);\r\n                        }\r\n\r\n                        move(index, slidePos[index] + width, speed);\r\n                        move(circle(index - 1), slidePos[circle(index - 1)] + width, speed);\r\n                        index = circle(index - 1);\r\n\r\n                    }\r\n\r\n                    options.callback && options.callback(index, slides[index]);\r\n\r\n                } else {\r\n\r\n                    if (options.continuous) {\r\n\r\n                        move(circle(index - 1), -width, speed);\r\n                        move(index, 0, speed);\r\n                        move(circle(index + 1), width, speed);\r\n\r\n                    } else {\r\n\r\n                        move(index - 1, -width, speed);\r\n                        move(index, 0, speed);\r\n                        move(index + 1, width, speed);\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n            // kill touchmove and touchend event listeners until touchstart called again\r\n            element.removeEventListener('touchmove', events, false)\r\n            element.removeEventListener('touchend', events, false)\r\n\r\n        },\r\n        transitionEnd: function (event) {\r\n\r\n            if (parseInt(event.target.getAttribute('data-index'), 10) == index) {\r\n\r\n                if (delay) begin();\r\n\r\n                options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    // trigger setup\r\n    setup();\r\n\r\n    // start auto slideshow if applicable\r\n    if (delay) begin();\r\n\r\n\r\n    // add event listeners\r\n    if (browser.addEventListener) {\r\n\r\n        // set touchstart event on element\r\n        if (browser.touch) element.addEventListener('touchstart', events, false);\r\n\r\n        if (browser.transitions) {\r\n            element.addEventListener('webkitTransitionEnd', events, false);\r\n            element.addEventListener('msTransitionEnd', events, false);\r\n            element.addEventListener('oTransitionEnd', events, false);\r\n            element.addEventListener('otransitionend', events, false);\r\n            element.addEventListener('transitionend', events, false);\r\n        }\r\n\r\n        // set resize event on window\r\n        window.addEventListener('resize', events, false);\r\n\r\n    } else {\r\n\r\n        window.onresize = function () {\r\n            setup()\r\n        }; // to play nice with old IE\r\n\r\n    }\r\n\r\n    // expose the Swipe API\r\n    return {\r\n        setup: function () {\r\n\r\n            setup();\r\n\r\n        },\r\n        slide: function (to, speed) {\r\n\r\n            // cancel slideshow\r\n            stop();\r\n\r\n            slide(to, speed);\r\n\r\n        },\r\n        prev: function () {\r\n\r\n            // cancel slideshow\r\n            stop();\r\n\r\n            prev();\r\n\r\n        },\r\n        next: function () {\r\n\r\n            // cancel slideshow\r\n            stop();\r\n\r\n            next();\r\n\r\n        },\r\n        stop: function () {\r\n\r\n            // cancel slideshow\r\n            stop();\r\n\r\n        },\r\n        getPos: function () {\r\n\r\n            // return current index position\r\n            return index;\r\n\r\n        },\r\n        getNumSlides: function () {\r\n\r\n            // return total number of slides\r\n            return length;\r\n        },\r\n        kill: function () {\r\n\r\n            // cancel slideshow\r\n            stop();\r\n\r\n            // reset element\r\n            element.style.width = '';\r\n            element.style.left = '';\r\n\r\n            // reset slides\r\n            var pos = slides.length;\r\n            while (pos--) {\r\n\r\n                var slide = slides[pos];\r\n                slide.style.width = '';\r\n                slide.style.left = '';\r\n\r\n                if (browser.transitions) translate(pos, 0, 0);\r\n\r\n            }\r\n\r\n            // removed event listeners\r\n            if (browser.addEventListener) {\r\n\r\n                // remove current event listeners\r\n                element.removeEventListener('touchstart', events, false);\r\n                element.removeEventListener('webkitTransitionEnd', events, false);\r\n                element.removeEventListener('msTransitionEnd', events, false);\r\n                element.removeEventListener('oTransitionEnd', events, false);\r\n                element.removeEventListener('otransitionend', events, false);\r\n                element.removeEventListener('transitionend', events, false);\r\n                window.removeEventListener('resize', events, false);\r\n\r\n            }\r\n            else {\r\n\r\n                window.onresize = null;\r\n\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n}\r\n\r\nif (typeof define === 'function' && define.amd) {\r\n    define([], function () {\r\n        \"use strict\";\r\n        return function (ele, params) {\r\n            return new Swipe(ele, params);\r\n        }\r\n    });\r\n} else if (typeof module !== 'undefined' && module.exports) {\r\n    (function ($) {\r\n        module.exports = function (ele, params) {\r\n            return new Swipe(ele, params);\r\n        }\r\n    })(window.jQuery || window.Zepto)\r\n} else {\r\n    if (window.jQuery || window.Zepto) {\r\n        (function ($) {\r\n            $.fn.Swipe = function (params) {\r\n                return this.each(function () {\r\n                    $(this).data('Swipe', new Swipe($(this)[0], params));\r\n                });\r\n            }\r\n        })(window.jQuery || window.Zepto)\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/module/m/assets/js/swipe.js\n// module id = 27\n// module chunks = 3","// removed by extract-text-webpack-plugin\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/module/m/assets/sass/index.scss\n// module id = 23\n// module chunks = 3"],"sourceRoot":""}